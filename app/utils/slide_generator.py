import uuid
import os
import json
import re
from pptx import Presentation
from pptx.util import Inches, Pt
from pptx.dml.color import RGBColor
from app.models.models import PresentationRequest
from app.stores.presentation_store import store, save_metadata
from dotenv import load_dotenv
from openai import OpenAI  # âœ… new-style SDK

# Load API key
load_dotenv()
client = OpenAI(
    api_key=os.getenv("OPENROUTER_API_KEY"),
    base_url="https://openrouter.ai/api/v1"  # âœ… Required for OpenRouter
)

# Generate content using OpenRouter LLM
def generate_slide_content(topic: str, num_slides: int = 5):
    prompt = (
        f"Return ONLY valid JSON (no explanation). Generate {num_slides} PowerPoint slides on '{topic}'.\n"
        "Each slide should be a JSON object with:\n"
        "- title: str\n"
        "- points: list of 3â€“5 bullet points\n"
        "- citation: short source string\n"
        "Respond ONLY with a JSON array like:\n"
        "[{\"title\": \"Slide 1\", \"points\": [\"pt1\", \"pt2\"], \"citation\": \"source\"}, ...]"
    )

    try:
        response = client.chat.completions.create(
            model="mistralai/mixtral-8x7b-instruct",
            messages=[{"role": "user", "content": prompt}],
            temperature=0.7,
        )

        content = response.choices[0].message.content.strip()
        print("[DEBUG] GPT Output:\n", content)  # Optional: can comment out later

        # ðŸ§¼ Extract only JSON block (starts with [, ends with ])
        json_start = content.find("[")
        json_end = content.rfind("]") + 1
        clean_json = content[json_start:json_end]

        # Remove control characters if any
        clean_json = re.sub(r"[\x00-\x1F]+", "", clean_json)

        return json.loads(clean_json)
    except json.JSONDecodeError:
        raise RuntimeError("Failed to parse LLM response as valid JSON.")
    except Exception as e:
        raise RuntimeError(f"OpenRouter GPT Error: {e}")

# Apply font and color theme
def apply_theme(text_frame, font="Arial", color_hex="#000000"):
    rgb = RGBColor.from_string(color_hex.strip("#"))
    for paragraph in text_frame.paragraphs:
        for run in paragraph.runs:
            run.font.name = font
            run.font.size = Pt(18)
            run.font.color.rgb = rgb

# Generate presentation from user payload
def generate_presentation(payload: PresentationRequest):
    prs = Presentation()
    slides_data = generate_slide_content(payload.topic, payload.config.num_slides)

    # Title slide
    title_slide = prs.slides.add_slide(prs.slide_layouts[0])
    title_slide.shapes.title.text = payload.topic
    title_slide.placeholders[1].text = "Generated by OpenRouter LLM"

    # Content slides
    for slide_info in slides_data:
        slide = prs.slides.add_slide(prs.slide_layouts[1])
        slide.shapes.title.text = slide_info["title"]
        tf = slide.placeholders[1].text_frame
        tf.clear()

        for point in slide_info["points"]:
            tf.add_paragraph().text = point

        apply_theme(tf, font=payload.config.font, color_hex=payload.config.color_theme)

        citation_box = slide.shapes.add_textbox(Inches(0.5), Inches(6.5), Inches(8), Inches(0.4))
        citation_tf = citation_box.text_frame
        citation_tf.text = f"Source: {slide_info.get('citation', 'N/A')}"
        apply_theme(citation_tf, font=payload.config.font, color_hex="#888888")

    # Save presentation
    try:
        file_id = str(uuid.uuid4())
        output_dir = os.path.join(os.getcwd(), "samples")
        os.makedirs(output_dir, exist_ok=True)
        file_path = os.path.join(output_dir, f"{file_id}.pptx")
        prs.save(file_path)
    except Exception as e:
        raise RuntimeError(f"Failed to save presentation file: {e}")

    # Store for later retrieval
    try:
        save_metadata(file_id, {
            "file_path": file_path,
            "topic": payload.topic,
            "config": payload.config.dict()
        })

        return file_id, file_path
    except Exception as e:
        raise RuntimeError(f"Failed to store metadata: {e}")
